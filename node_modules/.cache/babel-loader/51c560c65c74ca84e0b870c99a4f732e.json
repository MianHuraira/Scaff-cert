{"ast":null,"code":"import { createFactory as t, $eq as r, $ne as i, $lt as n, $lte as e, $gt as u, $gte as o, $in as s, $nin as f, $all as a, $size as c, $regex as h, $options as v, $elemMatch as l, $exists as d, eq as b, ne as y, lt as p, lte as w, gt as g, gte as E, within as A, nin as $, all as j, size as m, regex as M, elemMatch as x, exists as O, and as F } from \"@ucast/mongo2js\";\nfunction _(t, r) {\n  for (var i = 0; i < r.length; i++) {\n    var n = r[i];\n    n.enumerable = n.enumerable || false;\n    n.configurable = true;\n    if (\"value\" in n) n.writable = true;\n    Object.defineProperty(t, n.key, n);\n  }\n}\nfunction P(t, r, i) {\n  if (r) _(t.prototype, r);\n  if (i) _(t, i);\n  return t;\n}\nfunction R() {\n  R = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var i = arguments[r];\n      for (var n in i) if (Object.prototype.hasOwnProperty.call(i, n)) t[n] = i[n];\n    }\n    return t;\n  };\n  return R.apply(this, arguments);\n}\nfunction k(t, r) {\n  t.prototype = Object.create(r.prototype);\n  t.prototype.constructor = t;\n  B(t, r);\n}\nfunction B(t, r) {\n  B = Object.setPrototypeOf || function t(r, i) {\n    r.__proto__ = i;\n    return r;\n  };\n  return B(t, r);\n}\nfunction C(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\nfunction T(t) {\n  return Array.isArray(t) ? t : [t];\n}\nvar q = \"__caslSubjectType__\";\nfunction z(t, r) {\n  if (r) if (!r.hasOwnProperty(q)) Object.defineProperty(r, q, {\n    value: t\n  });else if (t !== r[q]) throw new Error(\"Trying to cast object to subject type \" + t + \" but previously it was casted to \" + r[q]);\n  return r;\n}\nvar S = function t(r) {\n  var i = typeof r;\n  return \"string\" === i || \"function\" === i;\n};\nvar Y = function t(r) {\n  return r.modelName || r.name;\n};\nvar D = function t(r) {\n  return \"string\" === typeof r ? r : Y(r);\n};\nfunction L(t) {\n  if (t.hasOwnProperty(q)) return t[q];\n  return Y(t.constructor);\n}\nfunction G(t, r, i) {\n  var n = T(r);\n  var e = 0;\n  while (e < n.length) {\n    var u = n[e++];\n    if (t.hasOwnProperty(u)) n = i(n, t[u]);\n  }\n  return n;\n}\nfunction H(t, r) {\n  if (\"string\" === typeof r && -1 !== t.indexOf(r)) return r;\n  for (var i = 0; i < r.length; i++) if (-1 !== t.indexOf(r[i])) return r[i];\n  return null;\n}\nvar I = function t(r, i) {\n  return r.concat(i);\n};\nfunction J(t, r) {\n  if (r in t) throw new Error('Cannot use \"' + r + \"\\\" as an alias because it's reserved action.\");\n  var i = Object.keys(t);\n  var n = function t(i, n) {\n    var e = H(i, n);\n    if (e) throw new Error(\"Detected cycle \" + e + \" -> \" + i.join(\", \"));\n    var u = \"string\" === typeof n && n === r || -1 !== i.indexOf(r) || Array.isArray(n) && -1 !== n.indexOf(r);\n    if (u) throw new Error('Cannot make an alias to \"' + r + '\" because this is reserved action');\n    return i.concat(n);\n  };\n  for (var e = 0; e < i.length; e++) G(t, i[e], n);\n}\nfunction K(t, r) {\n  if (!r || false !== r.skipValidate) J(t, r && r.anyAction || \"manage\");\n  return function (r) {\n    return G(t, r, I);\n  };\n}\nfunction N(t, r, i) {\n  for (var n = i; n < r.length; n++) t.push(r[n]);\n}\nfunction Q(t, r) {\n  if (!t || !t.length) return r || [];\n  if (!r || !r.length) return t || [];\n  var i = 0;\n  var n = 0;\n  var e = [];\n  while (i < t.length && n < r.length) if (t[i].priority < r[n].priority) {\n    e.push(t[i]);\n    i++;\n  } else {\n    e.push(r[n]);\n    n++;\n  }\n  N(e, t, i);\n  N(e, r, n);\n  return e;\n}\nfunction U(t, r, i) {\n  var n = t.get(r);\n  if (!n) {\n    n = i();\n    t.set(r, n);\n  }\n  return n;\n}\nvar V = function t(r) {\n  return r;\n};\nfunction W(t, r) {\n  if (Array.isArray(t.fields) && !t.fields.length) throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");\n  if (t.fields && !r.fieldMatcher) throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  if (t.conditions && !r.conditionsMatcher) throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n}\nvar X = function () {\n  function t(t, r, i) {\n    if (void 0 === i) i = 0;\n    W(t, r);\n    this.action = r.resolveAction(t.action);\n    this.subject = t.subject;\n    this.inverted = !!t.inverted;\n    this.conditions = t.conditions;\n    this.reason = t.reason;\n    this.fields = t.fields ? T(t.fields) : void 0;\n    this.priority = i;\n    this.t = r;\n  }\n  var r = t.prototype;\n  r.i = function t() {\n    if (this.conditions && !this.u) this.u = this.t.conditionsMatcher(this.conditions);\n    return this.u;\n  };\n  r.matchesConditions = function t(r) {\n    if (!this.conditions) return true;\n    if (!r || S(r)) return !this.inverted;\n    var i = this.i();\n    return i(r);\n  };\n  r.matchesField = function t(r) {\n    if (!this.fields) return true;\n    if (!r) return !this.inverted;\n    if (this.fields && !this.o) this.o = this.t.fieldMatcher(this.fields);\n    return this.o(r);\n  };\n  P(t, [{\n    key: \"ast\",\n    get: function t() {\n      var r = this.i();\n      return r ? r.ast : void 0;\n    }\n  }]);\n  return t;\n}();\nfunction Z(t, r) {\n  var i = {\n    value: t,\n    prev: r,\n    next: null\n  };\n  if (r) r.next = i;\n  return i;\n}\nfunction tt(t) {\n  if (t.next) t.next.prev = t.prev;\n  if (t.prev) t.prev.next = t.next;\n  t.next = t.prev = null;\n}\nvar rt = function t(r) {\n  return {\n    value: r.value,\n    prev: r.prev,\n    next: r.next\n  };\n};\nvar it = function t() {\n  return {\n    rules: [],\n    merged: false\n  };\n};\nvar nt = function t() {\n  return new Map();\n};\nvar et = function t(r, i) {\n  if (!r.h && i.fields) r.h = true;\n};\nvar ut = function () {\n  function t(t, r) {\n    if (void 0 === t) t = [];\n    if (void 0 === r) r = {};\n    this.h = false;\n    this.v = new Map();\n    this.l = {\n      conditionsMatcher: r.conditionsMatcher,\n      fieldMatcher: r.fieldMatcher,\n      resolveAction: r.resolveAction || V\n    };\n    this.p = r.anyAction || \"manage\";\n    this.g = r.anySubjectType || \"all\";\n    this.A = r.detectSubjectType || L;\n    this.$ = t;\n    this.j = this.m(t);\n  }\n  var r = t.prototype;\n  r.detectSubjectType = function t(r) {\n    if (S(r)) return r;\n    if (!r) return this.g;\n    return this.A(r);\n  };\n  r.update = function t(r) {\n    var i = {\n      rules: r,\n      ability: this,\n      target: this\n    };\n    this.M(\"update\", i);\n    this.$ = r;\n    this.j = this.m(r);\n    this.M(\"updated\", i);\n    return this;\n  };\n  r.m = function t(r) {\n    var i = new Map();\n    for (var n = r.length - 1; n >= 0; n--) {\n      var e = r.length - n - 1;\n      var u = new X(r[n], this.l, e);\n      var o = T(u.action);\n      var s = T(u.subject || this.g);\n      et(this, u);\n      for (var f = 0; f < s.length; f++) {\n        var a = U(i, s[f], nt);\n        for (var c = 0; c < o.length; c++) U(a, o[c], it).rules.push(u);\n      }\n    }\n    return i;\n  };\n  r.possibleRulesFor = function t(r, i) {\n    if (void 0 === i) i = this.g;\n    if (!S(i)) throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    var n = U(this.j, i, nt);\n    var e = U(n, r, it);\n    if (e.merged) return e.rules;\n    var u = r !== this.p && n.has(this.p) ? n.get(this.p).rules : void 0;\n    var o = Q(e.rules, u);\n    if (i !== this.g) o = Q(o, this.possibleRulesFor(r, this.g));\n    e.rules = o;\n    e.merged = true;\n    return o;\n  };\n  r.rulesFor = function t(r, i, n) {\n    var e = this.possibleRulesFor(r, i);\n    if (n && \"string\" !== typeof n) throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");\n    if (!this.h) return e;\n    return e.filter(function (t) {\n      return t.matchesField(n);\n    });\n  };\n  r.on = function t(r, i) {\n    var n = this;\n    var e = this.v.get(r) || null;\n    var u = Z(i, e);\n    this.v.set(r, u);\n    return function () {\n      var t = n.v.get(r);\n      if (!u.next && !u.prev && t === u) n.v.delete(r);else if (u === t) n.v.set(r, u.prev);\n      tt(u);\n    };\n  };\n  r.M = function t(r, i) {\n    var n = this.v.get(r) || null;\n    while (null !== n) {\n      var e = n.prev ? rt(n.prev) : null;\n      n.value(i);\n      n = e;\n    }\n  };\n  P(t, [{\n    key: \"rules\",\n    get: function t() {\n      return this.$;\n    }\n  }]);\n  return t;\n}();\nvar ot = function (t) {\n  k(PureAbility, t);\n  function PureAbility() {\n    return t.apply(this, arguments) || this;\n  }\n  var r = PureAbility.prototype;\n  r.can = function t() {\n    var r = this.relevantRuleFor.apply(this, arguments);\n    return !!r && !r.inverted;\n  };\n  r.relevantRuleFor = function t(r, i, n) {\n    var e = this.detectSubjectType(i);\n    var u = this.rulesFor(r, e, n);\n    for (var o = 0, s = u.length; o < s; o++) if (u[o].matchesConditions(i)) return u[o];\n    return null;\n  };\n  r.cannot = function t() {\n    return !this.can.apply(this, arguments);\n  };\n  return PureAbility;\n}(ut);\nvar st = {\n  $eq: r,\n  $ne: i,\n  $lt: n,\n  $lte: e,\n  $gt: u,\n  $gte: o,\n  $in: s,\n  $nin: f,\n  $all: a,\n  $size: c,\n  $regex: h,\n  $options: v,\n  $elemMatch: l,\n  $exists: d\n};\nvar ft = {\n  eq: b,\n  ne: y,\n  lt: p,\n  lte: w,\n  gt: g,\n  gte: E,\n  in: A,\n  nin: $,\n  all: j,\n  size: m,\n  regex: M,\n  elemMatch: x,\n  exists: O,\n  and: F\n};\nvar at = function r(i, n, e) {\n  return t(R({}, st, i), R({}, ft, n), e);\n};\nvar ct = t(st, ft);\nvar ht = /[-/\\\\^$+?.()|[\\]{}]/g;\nvar vt = /\\.?\\*+\\.?/g;\nvar lt = /\\*+/;\nvar dt = /\\./g;\nfunction bt(t, r, i) {\n  var n = \"*\" === i[0] || \".\" === t[0] && \".\" === t[t.length - 1] ? \"+\" : \"*\";\n  var e = -1 === t.indexOf(\"**\") ? \"[^.]\" : \".\";\n  var u = t.replace(dt, \"\\\\$&\").replace(lt, e + n);\n  return r + t.length === i.length ? \"(?:\" + u + \")?\" : u;\n}\nfunction yt(t, r, i) {\n  if (\".\" === t && (\"*\" === i[r - 1] || \"*\" === i[r + 1])) return t;\n  return \"\\\\\" + t;\n}\nfunction pt(t) {\n  var r = t.map(function (t) {\n    return t.replace(ht, yt).replace(vt, bt);\n  });\n  var i = r.length > 1 ? \"(?:\" + r.join(\"|\") + \")\" : r[0];\n  return new RegExp(\"^\" + i + \"$\");\n}\nvar wt = function t(r) {\n  var i;\n  return function (t) {\n    if (\"undefined\" === typeof i) i = r.every(function (t) {\n      return -1 === t.indexOf(\"*\");\n    }) ? null : pt(r);\n    return null === i ? -1 !== r.indexOf(t) : i.test(t);\n  };\n};\nvar gt = function (t) {\n  k(Ability, t);\n  function Ability(r, i) {\n    if (void 0 === r) r = [];\n    if (void 0 === i) i = {};\n    return t.call(this, r, R({\n      conditionsMatcher: ct,\n      fieldMatcher: wt\n    }, i)) || this;\n  }\n  return Ability;\n}(ot);\nvar Et = function () {\n  function t(t) {\n    this.O = t;\n  }\n  var r = t.prototype;\n  r.because = function t(r) {\n    this.O.reason = r;\n    return this;\n  };\n  return t;\n}();\nvar At = function () {\n  function AbilityBuilder(t) {\n    this.rules = [];\n    this.F = t;\n    this.can = this.can.bind(this);\n    this.cannot = this.cannot.bind(this);\n    this.build = this.build.bind(this);\n  }\n  var t = AbilityBuilder.prototype;\n  t.can = function t(r, i, n, e) {\n    var u = {\n      action: r\n    };\n    if (i) {\n      u.subject = i;\n      if (Array.isArray(n) || \"string\" === typeof n) u.fields = n;else if (\"undefined\" !== typeof n) u.conditions = n;\n      if (\"undefined\" !== typeof e) u.conditions = e;\n    }\n    this.rules.push(u);\n    return new Et(u);\n  };\n  t.cannot = function t(r, i, n, e) {\n    var u = this.can(r, i, n, e);\n    u.O.inverted = true;\n    return u;\n  };\n  t.build = function t(r) {\n    return new this.F(this.rules, r);\n  };\n  return AbilityBuilder;\n}();\nfunction defineAbility(t, r) {\n  var i = new At(gt);\n  var n = t(i.can, i.cannot);\n  if (n && \"function\" === typeof n.then) return n.then(function () {\n    return i.build(r);\n  });\n  return i.build(r);\n}\nvar $t = function t(r) {\n  return 'Cannot execute \"' + r.action + '\" on \"' + r.subjectType + '\"';\n};\nvar jt = function t(r) {\n  this.message = r;\n};\njt.prototype = Object.create(Error.prototype);\nvar mt = function (t) {\n  k(ForbiddenError, t);\n  ForbiddenError.setDefaultMessage = function t(r) {\n    this._ = \"string\" === typeof r ? function () {\n      return r;\n    } : r;\n  };\n  ForbiddenError.from = function t(r) {\n    return new this(r);\n  };\n  function ForbiddenError(r) {\n    var i;\n    i = t.call(this, \"\") || this;\n    i.ability = r;\n    if (\"function\" === typeof Error.captureStackTrace) {\n      i.name = \"ForbiddenError\";\n      Error.captureStackTrace(C(i), i.constructor);\n    }\n    return i;\n  }\n  var r = ForbiddenError.prototype;\n  r.setMessage = function t(r) {\n    this.message = r;\n    return this;\n  };\n  r.throwUnlessCan = function t() {\n    var r;\n    var i = (r = this.ability).relevantRuleFor.apply(r, arguments);\n    if (i && !i.inverted) return;\n    this.action = arguments.length <= 0 ? void 0 : arguments[0];\n    this.subject = arguments.length <= 1 ? void 0 : arguments[1];\n    this.subjectType = D(this.ability.detectSubjectType(arguments.length <= 1 ? void 0 : arguments[1]));\n    this.field = arguments.length <= 2 ? void 0 : arguments[2];\n    var n = i ? i.reason : \"\";\n    this.message = this.message || n || this.constructor._(this);\n    throw this;\n  };\n  return ForbiddenError;\n}(jt);\nmt._ = $t;\nvar Mt = Object.freeze({\n  __proto__: null\n});\nexport { gt as Ability, At as AbilityBuilder, mt as ForbiddenError, ot as PureAbility, at as buildMongoQueryMatcher, K as createAliasResolver, defineAbility, L as detectSubjectType, wt as fieldPatternMatcher, $t as getDefaultErrorMessage, Mt as hkt, ct as mongoQueryMatcher, z as subject, T as wrapArray };","map":{"version":3,"names":["T","t","Array","isArray","q","z","r","hasOwnProperty","Object","defineProperty","value","Error","S","i","Y","modelName","name","D","L","constructor","G","n","e","length","u","H","indexOf","I","concat","J","keys","join","K","skipValidate","anyAction","N","push","Q","priority","U","get","set","V","W","fields","fieldMatcher","conditions","conditionsMatcher","X","action","resolveAction","subject","inverted","reason","prototype","matchesConditions","matchesField","o","P","key","ast","Z","prev","next","tt","rt","it","rules","merged","nt","Map","et","h","ut","v","l","p","g","anySubjectType","A","detectSubjectType","$","j","m","update","ability","target","M","s","f","a","c","possibleRulesFor","has","rulesFor","filter","on","delete","ot","k","PureAbility","apply","arguments","can","relevantRuleFor","cannot","st","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","$options","$elemMatch","$exists","d","ft","eq","b","ne","y","lt","lte","w","gt","gte","E","in","nin","all","size","regex","elemMatch","x","exists","O","and","F","at","R","ct","ht","vt","dt","bt","replace","yt","pt","map","RegExp","wt","every","test","Ability","call","Et","because","At","AbilityBuilder","bind","build","defineAbility","then","$t","subjectType","jt","message","create","mt","ForbiddenError","setDefaultMessage","_","from","captureStackTrace","C","setMessage","throwUnlessCan","field","Mt","freeze","__proto__","buildMongoQueryMatcher","createAliasResolver","fieldPatternMatcher","getDefaultErrorMessage","hkt","mongoQueryMatcher","wrapArray"],"sources":["../../src/utils.ts","../../src/Rule.ts","../../src/structures/LinkedItem.ts","../../src/RuleIndex.ts","../../src/PureAbility.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\ndeclare const $abilities: unique symbol;\ndeclare const $conditions: unique symbol;\ninterface WithGenerics {\n  [$abilities]: any\n  [$conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof $abilities],\n  conditions: T[typeof $conditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst analyze = (index: any, rule: Rule<any, any>) => {\n  if (!index._hasPerFieldRules && rule.fields) {\n    index._hasPerFieldRules = true;\n  }\n};\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<Conditions>;\n  private readonly _detectSubjectType!: Required<RuleIndexOptions<A, Conditions>>['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  readonly [$abilities]!: A;\n  readonly [$conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object;\n    if (!object) return this._anySubjectType;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      analyze(this, rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[]\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    const tail = this._events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    this._events.set(event, item);\n\n    return () => {\n      const currentTail = this._events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        this._events.delete(event);\n      } else if (item === currentTail) {\n        this._events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T extends {}, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public } from './RuleIndex';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<Ability<any, MongoQuery>> {}\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  AnyObject,\n  AnyClass,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends string\n    ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n      ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n      : AnyObject\n    : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: AnyClass<T>;\n\n  constructor(AbilityType: AnyClass<T>) {\n    this._AbilityType = AbilityType;\n    this.can = this.can.bind(this as any);\n    this.cannot = this.cannot.bind(this as any);\n    this.build = this.build.bind(this as any);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return new this._AbilityType(this.rules, options);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder(Ability as unknown as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U) {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(args[1]));\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}